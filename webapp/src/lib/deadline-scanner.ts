import { prisma } from "@/lib/db";
import { sendEmail, deadlineReminderEmail } from "@/lib/email";

export interface ScanResult {
  scanned: number;
  remindersCreated: number;
  emailsSent: number;
  errors: string[];
}

const REMINDER_THRESHOLDS = [90, 60, 30, 7] as const;

/**
 * Scan all users with credentials and create/send deadline reminders.
 * Designed to be called by a cron endpoint or manual trigger.
 */
export async function scanDeadlines(): Promise<ScanResult> {
  const result: ScanResult = { scanned: 0, remindersCreated: 0, emailsSent: 0, errors: [] };

  // Find all user-credentials with renewal deadlines
  const userCredentials = await prisma.userCredential.findMany({
    where: {
      renewalDeadline: { not: null },
    },
    include: {
      user: { select: { id: true, name: true, email: true } },
      credential: { select: { id: true, name: true, hoursRequired: true } },
    },
  });

  result.scanned = userCredentials.length;

  const now = new Date();

  for (const uc of userCredentials) {
    if (!uc.renewalDeadline || !uc.user.email) continue;

    const deadline = new Date(uc.renewalDeadline);
    const daysUntil = Math.ceil((deadline.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    // Skip if deadline is past or more than 90 days out
    if (daysUntil < 0 || daysUntil > 90) continue;

    // Determine which threshold we are at
    const threshold = REMINDER_THRESHOLDS.find((t) => daysUntil <= t);
    if (!threshold) continue;

    // Check if we already sent a reminder for this threshold
    const existingReminder = await prisma.reminder.findFirst({
      where: {
        userId: uc.userId,
        credentialId: uc.credentialId,
        type: "deadline",
        metadata: { contains: `"threshold":${threshold}` },
      },
    });

    if (existingReminder) continue;

    // Determine urgency level for the message
    let urgencyPrefix = "";
    if (daysUntil <= 7) urgencyPrefix = "URGENT: ";
    else if (daysUntil <= 30) urgencyPrefix = "Action needed: ";

    // Calculate hours progress for enhanced messaging
    const userCpdRecords = await prisma.cpdRecord.findMany({
      where: { userId: uc.userId, status: "completed" },
    });
    const totalLogged = userCpdRecords.reduce((s, r) => s + r.hours, 0) + (uc.hoursCompleted ?? 0);
    const hoursRequired = uc.credential.hoursRequired ?? 0;
    const hoursRemaining = Math.max(0, hoursRequired - totalLogged);

    const title = `${urgencyPrefix}${uc.credential.name} CPD deadline in ${daysUntil} days`;
    const progressInfo = hoursRequired > 0
      ? ` You have completed ${Math.round(totalLogged * 100) / 100} of ${hoursRequired} required hours.`
      : "";
    const message = `Your ${uc.credential.name} CPD cycle ends on ${deadline.toISOString().split("T")[0]}. You have ${daysUntil} days remaining.${progressInfo}`;

    try {
      // Create reminder record
      await prisma.reminder.create({
        data: {
          userId: uc.userId,
          type: "deadline",
          title,
          message,
          triggerDate: now,
          channel: "email",
          status: "sent",
          sentAt: now,
          credentialId: uc.credentialId,
          metadata: JSON.stringify({
            threshold,
            daysUntilDeadline: daysUntil,
            renewalDeadline: deadline.toISOString(),
            autoGenerated: true,
            hoursCompleted: Math.round(totalLogged * 100) / 100,
            hoursRequired,
            hoursRemaining: Math.round(hoursRemaining * 100) / 100,
          }),
        },
      });
      result.remindersCreated++;

      // Send email
      const emailOpts = deadlineReminderEmail(
        uc.user.name ?? "there",
        uc.credential.name,
        daysUntil,
        deadline.toISOString().split("T")[0]
      );
      emailOpts.to = uc.user.email;

      const emailResult = await sendEmail(emailOpts);
      if (emailResult.success) {
        result.emailsSent++;
      } else {
        result.errors.push(`Email failed for ${uc.user.email}: delivery failed`);
      }
    } catch (err) {
      result.errors.push(`Error processing ${uc.user.email}: ${err instanceof Error ? err.message : "unknown"}`);
    }
  }

  return result;
}

/**
 * Check pending reminders that have not been sent yet and send them.
 * The Reminder model does not have a direct user relation, so we look up
 * each user separately via prisma.user.findUnique.
 */
export async function processPendingReminders(): Promise<{ sent: number; failed: number }> {
  const pendingReminders = await prisma.reminder.findMany({
    where: {
      status: "pending",
      channel: { in: ["email", "both"] },
      triggerDate: { lte: new Date() },
    },
    take: 100,
  });

  let sent = 0;
  let failed = 0;

  for (const reminder of pendingReminders) {
    // Look up the user for this reminder
    const user = await prisma.user.findUnique({
      where: { id: reminder.userId },
      select: { name: true, email: true },
    });

    if (!user?.email) {
      failed++;
      continue;
    }

    try {
      const emailResult = await sendEmail({
        to: user.email,
        subject: reminder.title,
        text: reminder.message ?? reminder.title,
      });

      await prisma.reminder.update({
        where: { id: reminder.id },
        data: {
          status: emailResult.success ? "sent" : "failed",
          sentAt: emailResult.success ? new Date() : undefined,
        },
      });

      if (emailResult.success) sent++;
      else failed++;
    } catch {
      await prisma.reminder.update({
        where: { id: reminder.id },
        data: { status: "failed" },
      });
      failed++;
    }
  }

  return { sent, failed };
}
